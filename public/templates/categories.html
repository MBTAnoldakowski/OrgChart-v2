<script>
    // this variable counts how many elements there are so far, to make correct rows.
    var count = 0;
    var jsonTree;

    function loadJSON(callback) {

        var xobj = new XMLHttpRequest();
        xobj.overrideMimeType("application/json");
        xobj.open('GET', 'resources/cats.json', true); // Replace 'my_data' with the path to your file
        xobj.onreadystatechange = function () {
            if (xobj.readyState == 4 && xobj.status == "200") {
                // Required use of an anonymous callback as .open will NOT return a value but simply returns undefined in asynchronous mode
                callback(xobj.responseText);
            }
        };
        xobj.send(null);
    }

    function init() {
        loadJSON(function (response) {
            // Parse JSON string into object
            jsonTree = JSON.parse(response);
        });
    }

    init();

    function initializeRows() {
        var colIdCount = 0;
        var rowIdName = "";
        var colIdName = "";
        for (data in jsonTree.children) {
            if (count % 3 === 0) {
                var div = document.createElement("div");
                div.setAttribute('class', 'row');
                div.setAttribute('id', 'row' + count);
                rowIdName = 'row' + count;
                colIdCount = 0;
                document.body.appendChild(div);
            }
            var col = document.createElement("div");
            col.setAttribute('class', 'col-md-4');
            colIdName = rowIdName + 'col' + colIdCount;
            col.setAttribute('id', colIdName);
            document.getElementById(rowIdName).appendChild(col);
            colIdCount++;
            count++;
        }

    }

    function initD3() {

        // ************** Generate the tree diagram	 *****************
        var margin = {top: 5, right: 5, bottom: 5, left: 5},
            width = 400 - margin.right - margin.left,
            height = 400 - margin.top - margin.bottom;

        var i = 0,
            //sets the amount of time it takes the tree opening animation to run
            duration = 750,
            root;

        var tree = d3.layout.tree()
            .size([height, width]);

        var diagonal = d3.svg.diagonal()
            .projection(function (d) {
                return [d.y, d.x];
            });

        var svg = d3.select("#row0col0").append("svg")
            .attr("width", width + margin.right + margin.left)
            .attr("height", height + margin.top + margin.bottom)
            .append("g")
            .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

        root = jsonTree.children[0];

        update(root);

        function update(source) {
            // Compute the new tree layout.
            var nodes = tree.nodes(root).reverse(),
                links = tree.links(nodes);


            // Normalize for fixed-depth.
            nodes.forEach(function (d) {
                d.y = d.depth * 50;    // I don't know specifically what this does,
                                        // but I do know that changing the number
                                        // changes the width of the tree that is displayed
            }); //180

            // Update the nodes
            var node = svg.selectAll("g.node")
                .data(nodes, function (d) {
                    return d.id || (d.id = ++i);
                });

            // Enter any new nodes at the parent's previous position.
            var nodeEnter = node.enter().append("g")
                .attr("class", "node")
                .attr("transform", function (d) {
                    return "translate(" + source.y + "," + source.x + ")";
                });

            nodeEnter.append("circle")
                .attr("r", 1e-6);
            // appends the name text to the nodes
            nodeEnter.append("text")
                .attr("x", function (d) {
                    return d.children || d._children ? -10 : 10;
                })
                .attr("dy", ".35em")
                .attr("text-anchor", function (d) {
                    return d.children || d._children ? "end" : "start";
                })
                //the name is appended to the dot right here
                .text(function (d) {
                    return d.name;
                })
                .style("fill-opacity", 1)
                // the names are styled here based on PO data
                .style("fill", "black");
            // Transition nodes to their new position.
            var nodeUpdate = node.transition()
                .duration(duration)
                .attr("transform", function (d) {
                    return "translate(" + d.y + "," + d.x + ")";
                });

            // size/style the circles based on levels
            nodeUpdate.select("circle")
                .attr("r", function (d) {
                    // change this number to make dots bigger or smaller
                    return 6;
                });

            // Transition exiting nodes to the parent's new position.
            var nodeExit = node.exit().transition()
                .duration(duration)
                .attr("transform", function (d) {
                    return "translate(" + source.y + "," + source.x + ")";
                })
                .remove();

            nodeExit.select("circle")
                .attr("r", 1e-6);

            nodeExit.select("text")
                .style("fill-opacity", 1e-6);

            // Update the linksâ€¦
            var link = svg.selectAll("path.link")
                .data(links, function (d) {
                    return d.target.id;
                });

            // Enter any new links at the parent's previous position.
            link.enter().insert("path", "g")
                .attr("class", "link")
                .attr("d", function (d) {
                    var o = {x: source.x, y: source.y};
                    return diagonal({source: o, target: o});
                });

            // Transition links to their new position.
            link.transition()
                .duration(duration)
                .attr("d", diagonal);

            // Transition exiting nodes to the parent's new position.
            link.exit().transition()
                .duration(duration)
                .attr("d", function (d) {
                    var o = {x: source.x, y: source.y};
                    return diagonal({source: o, target: o});
                })
                .remove();

            // Stash the old positions for transition.
            nodes.forEach(function (d) {
                d.x0 = d.x;
                d.y0 = d.y;
            });
        }
    }


</script>